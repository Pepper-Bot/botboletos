'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensureH264 = undefined;

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _curry2 = require('lodash/curry');

var _curry3 = _interopRequireDefault(_curry2);

exports.getMediaDirectionFromSDP = getMediaDirectionFromSDP;
exports.reverseMediaDirection = reverseMediaDirection;
exports.limitBandwith = limitBandwith;
exports.kindToPropertyFragment = kindToPropertyFragment;
exports.getMediaDirectionFromSDPForAnswer = getMediaDirectionFromSDPForAnswer;
exports.boolToDirection = boolToDirection;
exports.getMediaDirectionFromTracks = getMediaDirectionFromTracks;

require('./webrtc-adapter-adapter');

var _sdpTransform = require('sdp-transform');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Pulls the direction line for the specified media kind from an sdp
 * @param {string} kind
 * @param {string} sdp
 * @protected
 * @returns {string}
 */
// we need to import the webrtc adapter before anything else happens
/* eslint-disable import/first */

function getMediaDirectionFromSDP(kind, sdp) {
  var query = kind === 'screen' ? {
    content: 'slides',
    type: 'video'
  } : {
    type: kind
  };

  var media = (0, _find3.default)((0, _sdpTransform.parse)(sdp).media, query);
  if (!media) {
    return 'inactive';
  }

  return media.direction;
}

/**
 * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)
 * @param {string} direction
 * @protected
 * @returns {string}
 */
function reverseMediaDirection(direction) {
  switch (direction) {
    case 'inactive':
    case 'sendrecv':
      return direction;
    case 'sendonly':
      return 'recvonly';
    case 'recvonly':
      return 'sendonly';
    default:
      throw new Error('direction "' + direction + '" is not valid');
  }
}

/**
 * Checks a given sdp to ensure it contains an offer for the h264 codec
 * @param {boolean} wantsVideo
 * @param {string} offer
 * @protected
 * @returns {string} returns the offer to simplify use in promise chains
 */
var ensureH264 = exports.ensureH264 = (0, _curry3.default)(function (wantsVideo, offer) {
  if (wantsVideo) {
    if (!offer.includes('m=video')) {
      throw new Error('No video section found in offer');
    }
    if (!/[hH]264/.test(offer)) {
      throw new Error('Offer does not include h264 codec');
    }
  }
  return offer;
});

/**
 * Adds a bandwith limit line to the sdp; without this line, calling fails
 * @param {Object} bandwidthLimit
 * @param {string} sdp SDP
 * @protected
 * @returns {string} The modified SDP
 */
function limitBandwith(_ref, sdp) {
  var audioBandwidthLimit = _ref.audioBandwidthLimit,
      videoBandwidthLimit = _ref.videoBandwidthLimit;

  return sdp.split('\r\n').reduce(function (lines, line) {
    lines.push(line);
    if (line.startsWith('m=')) {
      lines.push('b=TIAS:' + (line.includes('audio') ? audioBandwidthLimit : videoBandwidthLimit));
    }
    return lines;
  }, []).join('\r\n');
}

/**
 * Helper for dealing wait capitalization
 * @param {string} kind audio|video
 * @protected
 * @returns {string} Audio|Video
 */
function kindToPropertyFragment(kind) {
  return kind === 'audio' ? 'Audio' : 'Video';
}

/**
 * Like get getMediaDirectionFromSDP, but reverses the the result
 * @param {string} kind
 * @param {string} offerSdp
 * @protected
 * @returns {string}
 */
function getMediaDirectionFromSDPForAnswer(kind, offerSdp) {
  return reverseMediaDirection(getMediaDirectionFromSDP(kind, offerSdp));
}

/**
 * Converts a pair of booleans to a SDP direction string
 * @param {boolean} send
 * @param {boolean} recv
 * @protected
 * @returns {string}
 */
function boolToDirection(send, recv) {
  if (send && recv) {
    return 'sendrecv';
  }

  if (send) {
    return 'sendonly';
  }

  if (recv) {
    return 'recvonly';
  }

  return 'inactive';
}

/**
 * Determines the flow of media for a given kind of media on a peer connection
 * @param {string} kind
 * @param {RTCPeerConnection} pc
 * @protected
 * @returns {string}
 */
function getMediaDirectionFromTracks(kind, pc) {
  if (pc.signalingState === 'closed') {
    return 'inactive';
  }

  var send = false;
  var senders = pc.getSenders().filter(function (s) {
    return s.track.kind === kind;
  });

  send = senders.length > 0 && senders.reduce(function (acc, s) {
    return acc && s.track.enabled;
  }, true);

  // Ideally, we'd do something like this commented code, but as of
  // webrtc-adapter@5.0.4, receivers don't accurately reflect reality in Chrome.
  // let recv = false;
  // const receivers = pc
  //   .getReceivers()
  //   .filter((r) => r.track.kind === kind);

  // recv = receivers.length > 0 && receivers.reduce((acc, s) => acc && s.track.enabled, true);

  var remoteStreams = pc.getRemoteStreams();
  var recv = remoteStreams.length > 0 && remoteStreams.reduce(function (acc1, stream) {
    var tracks = stream.getTracks().filter(function (t) {
      return t.kind === kind;
    });

    return acc1 && tracks.length > 0 && tracks.reduce(function (acc, t) {
      return acc && t.enabled;
    }, true);
  }, true);

  return boolToDirection(send, recv);
}
//# sourceMappingURL=webrtc-helpers.js.map
