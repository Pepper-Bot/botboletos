{"version":3,"sources":["webrtc-helpers.js"],"names":["getMediaDirectionFromSDP","reverseMediaDirection","limitBandwith","kindToPropertyFragment","getMediaDirectionFromSDPForAnswer","boolToDirection","getMediaDirectionFromTracks","kind","sdp","query","content","type","media","direction","Error","ensureH264","wantsVideo","offer","includes","test","audioBandwidthLimit","videoBandwidthLimit","split","reduce","lines","line","push","startsWith","join","offerSdp","send","recv","pc","signalingState","senders","getSenders","filter","s","track","length","acc","enabled","remoteStreams","getRemoteStreams","acc1","stream","tracks","getTracks","t"],"mappings":"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","file":"webrtc-helpers.js","sourcesContent":["// we need to import the webrtc adapter before anything else happens\n/* eslint-disable import/first */\n\nimport './webrtc-adapter-adapter';\n\nimport {curry, find} from 'lodash';\nimport {parse} from 'sdp-transform';\n\n/**\n * Pulls the direction line for the specified media kind from an sdp\n * @param {string} kind\n * @param {string} sdp\n * @protected\n * @returns {string}\n */\nexport function getMediaDirectionFromSDP(kind, sdp) {\n  const query = kind === 'screen' ? {\n    content: 'slides',\n    type: 'video'\n  } : {\n    type: kind\n  };\n\n  const media = find(parse(sdp).media, query);\n  if (!media) {\n    return 'inactive';\n  }\n\n  return media.direction;\n}\n\n/**\n * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)\n * @param {string} direction\n * @protected\n * @returns {string}\n */\nexport function reverseMediaDirection(direction) {\n  switch (direction) {\n    case 'inactive':\n    case 'sendrecv':\n      return direction;\n    case 'sendonly':\n      return 'recvonly';\n    case 'recvonly':\n      return 'sendonly';\n    default:\n      throw new Error(`direction \"${direction}\" is not valid`);\n  }\n}\n\n/**\n * Checks a given sdp to ensure it contains an offer for the h264 codec\n * @param {boolean} wantsVideo\n * @param {string} offer\n * @protected\n * @returns {string} returns the offer to simplify use in promise chains\n */\nexport const ensureH264 = curry((wantsVideo, offer) => {\n  if (wantsVideo) {\n    if (!offer.includes('m=video')) {\n      throw new Error('No video section found in offer');\n    }\n    if (!/[hH]264/.test(offer)) {\n      throw new Error('Offer does not include h264 codec');\n    }\n  }\n  return offer;\n});\n\n/**\n * Adds a bandwith limit line to the sdp; without this line, calling fails\n * @param {Object} bandwidthLimit\n * @param {string} sdp SDP\n * @protected\n * @returns {string} The modified SDP\n */\nexport function limitBandwith({audioBandwidthLimit, videoBandwidthLimit}, sdp) {\n  return sdp.split('\\r\\n').reduce((lines, line) => {\n    lines.push(line);\n    if (line.startsWith('m=')) {\n      lines.push(`b=TIAS:${line.includes('audio') ? audioBandwidthLimit : videoBandwidthLimit}`);\n    }\n    return lines;\n  }, []).join('\\r\\n');\n}\n\n/**\n * Helper for dealing wait capitalization\n * @param {string} kind audio|video\n * @protected\n * @returns {string} Audio|Video\n */\nexport function kindToPropertyFragment(kind) {\n  return kind === 'audio' ? 'Audio' : 'Video';\n}\n\n/**\n * Like get getMediaDirectionFromSDP, but reverses the the result\n * @param {string} kind\n * @param {string} offerSdp\n * @protected\n * @returns {string}\n */\nexport function getMediaDirectionFromSDPForAnswer(kind, offerSdp) {\n  return reverseMediaDirection(getMediaDirectionFromSDP(kind, offerSdp));\n}\n\n\n/**\n * Converts a pair of booleans to a SDP direction string\n * @param {boolean} send\n * @param {boolean} recv\n * @protected\n * @returns {string}\n */\nexport function boolToDirection(send, recv) {\n  if (send && recv) {\n    return 'sendrecv';\n  }\n\n  if (send) {\n    return 'sendonly';\n  }\n\n  if (recv) {\n    return 'recvonly';\n  }\n\n  return 'inactive';\n}\n\n/**\n * Determines the flow of media for a given kind of media on a peer connection\n * @param {string} kind\n * @param {RTCPeerConnection} pc\n * @protected\n * @returns {string}\n */\nexport function getMediaDirectionFromTracks(kind, pc) {\n  if (pc.signalingState === 'closed') {\n    return 'inactive';\n  }\n\n  let send = false;\n  const senders = pc\n    .getSenders()\n    .filter((s) => s.track.kind === kind);\n\n  send = senders.length > 0 && senders.reduce((acc, s) => acc && s.track.enabled, true);\n\n  // Ideally, we'd do something like this commented code, but as of\n  // webrtc-adapter@5.0.4, receivers don't accurately reflect reality in Chrome.\n  // let recv = false;\n  // const receivers = pc\n  //   .getReceivers()\n  //   .filter((r) => r.track.kind === kind);\n\n  // recv = receivers.length > 0 && receivers.reduce((acc, s) => acc && s.track.enabled, true);\n\n  const remoteStreams = pc.getRemoteStreams();\n  const recv = remoteStreams.length > 0 && remoteStreams.reduce((acc1, stream) => {\n    const tracks = stream\n      .getTracks()\n      .filter((t) => t.kind === kind);\n\n    return acc1 && tracks.length > 0 && tracks.reduce((acc, t) => acc && t.enabled, true);\n  }, true);\n\n  return boolToDirection(send, recv);\n}\n"]}