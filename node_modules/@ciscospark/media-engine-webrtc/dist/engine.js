'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _dec, _dec2, _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13;

var _lodashDecorators = require('lodash-decorators');

var _coreDecorators = require('core-decorators');

var _common = require('@ciscospark/common');

var _commonEvented = require('@ciscospark/common-evented');

var _commonEvented2 = _interopRequireDefault(_commonEvented);

var _ampersandEvents = require('ampersand-events');

var _ampersandEvents2 = _interopRequireDefault(_ampersandEvents);

var _sdpTransform = require('sdp-transform');

var _grammar = require('sdp-transform/lib/grammar');

var _grammar2 = _interopRequireDefault(_grammar);

var _webrtcHelpers = require('./webrtc-helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  (0, _defineProperty2.default)(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

// Add support for our custom "content" attribute. Note: this seems to make
// parse() work correctly, but I don't think I could get write() to work.
if (!_grammar2.default.a.find(function (g) {
  return g.name === 'content';
})) {
  _grammar2.default.a.unshift({
    // name appears to be where we stick the value of this field in the parsed
    // media object
    name: 'content',
    // reg determines whether or not this line should be handled by this rule
    reg: /^content:(slides)/
  });
}

var DirectionContainer = (0, _common.make)(_weakMap2.default, _map2.default);
var targetMediaDirection = new DirectionContainer();

var capitalize = {
  audio: 'Audio',
  video: 'Video'
};

/**
 * Wrapper around targetMediaDirection.get which return `inactive` instead of
 * undefined
 * @param {WebRTCMediaEngine} target
 * @param {string} kind
 * @private
 * @returns {string}
 */
function getTargetMediaDirection(target, kind) {
  return targetMediaDirection.get(target, kind) || 'inactive';
}

/**
 * Interface for doing webrtc things
 * @protected
 */
var WebRTCMediaEngine = (_dec = (0, _common.whileInFlight)('gumming'), _dec2 = (0, _lodashDecorators.debounce)(500), (_class = function () {
  (0, _createClass3.default)(WebRTCMediaEngine, [{
    key: 'audioDirection',


    /**
     * Returns the current audio direction
     * @returns {string}
     */
    get: function get() {
      return (0, _webrtcHelpers.getMediaDirectionFromTracks)('audio', this.pc);
    }

    /**
     * Returns the current video direction
     * @returns {string}
     */

  }, {
    key: 'videoDirection',
    get: function get() {
      return (0, _webrtcHelpers.getMediaDirectionFromTracks)('video', this.pc);
    }

    /**
     * Returns the current screen direction
     * @returns {string}
     */

  }, {
    key: 'screenDirection',
    get: function get() {
      return !this.localScreenShare || this.localScreenShare.getTracks().length === 0 ? 'inactive' : 'sendonly';
    }

    /**
     * Constructor
     * @param {Object} attrs
     * @param {Object} options
     * @param {Logger} options.logger (optional): defaults to console
     * @returns {WebRTCMediaEngine}
     */

  }], [{
    key: 'getUserMedia',

    /**
     * Wrapper around navigator.mediaDevices.getUserMedia
     *
     * @param {MediaStreamContraints} constraints
     * @returns {Promise<MediaStream>}
     */
    value: function getUserMedia(constraints) {
      var finalConstraints = (0, _defaults3.default)({}, constraints, { fake: process.env.NODE_ENV === 'test' });
      return navigator.mediaDevices.getUserMedia(finalConstraints);
    }
    /**
     * Represents the local party's outgoing stream. Instantiated when the class
     * is instantiated.
     * @type {MediaStream}
     */

    /**
     * Represent the remote party's incoming media. Instantiated when the class is
     * instantiated.
     * @type {MediaStream}
     */

    /**
     * Reserved for future use
     * @type {MediaStream}
     */


    /**
     * Peer Connection
     * @type {RTCPeerConnection}
     */

    /**
     * The most-recently produced offer
     * @private
     */

    /**
     * The most-recently accepted answer
     * @private
     */

  }]);

  function WebRTCMediaEngine() {
    var _this = this;

    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, WebRTCMediaEngine);
    this.logger = console;

    _initDefineProp(this, 'localMediaStream', _descriptor, this);

    _initDefineProp(this, 'remoteMediaStream', _descriptor2, this);

    _initDefineProp(this, 'localScreenShare', _descriptor3, this);

    this.pc = new RTCPeerConnection({
      iceServers: [],
      bundlePolicy: 'max-compat'
    });

    _initDefineProp(this, 'offerSdp', _descriptor4, this);

    _initDefineProp(this, 'answerSdp', _descriptor5, this);

    _initDefineProp(this, 'sendingAudio', _descriptor6, this);

    _initDefineProp(this, 'sendingVideo', _descriptor7, this);

    _initDefineProp(this, 'receivingAudio', _descriptor8, this);

    _initDefineProp(this, 'receivingVideo', _descriptor9, this);

    _initDefineProp(this, 'ended', _descriptor10, this);

    this.negotiationNeeded = false;
    this.bandwidthLimit = {
      audioBandwidthLimit: 60000,
      videoBandwidthLimit: 1000000
    };

    _initDefineProp(this, 'constraints', _descriptor11, this);

    _initDefineProp(this, 'offerOptions', _descriptor12, this);

    _initDefineProp(this, 'gumming', _descriptor13, this);

    if (options.parent) {
      // This is a bit of weirdness to maintain amp-state compatibility
      process.nextTick(function () {
        if (options.parent.logger) {
          _this.logger = options.parent.logger;
        }
      });
    } else if (attrs.logger) {
      this.logger = attrs.logger;
    }

    this.pc.onnegotiationneeded = function () {
      if (_this.answerSdp && !_this.negotiationNeeded) {
        _this.logger.info('peer connection emitted negotiationneeded');
        _this.negotiationNeeded = true;
        _this.triggerNegotiationNeeded();
      }
    };

    // Note: adapter.js doesn't seem to fully shim the track event.
    // addEventListener doesn't appear to work for it in chrome
    this.pc.ontrack = function (event) {
      _this.trigger('track');
      var stream = _this.remoteMediaStream || new MediaStream();
      event.streams[0].getTracks().forEach(function (track) {
        stream.addTrack(track);
        track.onended = function () {
          stream.removeTrack(track);
          track.onended = undefined;
          try {
            _this['receiving' + capitalize[track.kind]] = (0, _webrtcHelpers.getMediaDirectionFromTracks)(track.kind, _this.pc).includes('recv');
          } catch (err) {
            _this['receiving' + capitalize[track.kind]] = false;
          }
        };

        _this['receiving' + capitalize[track.kind]] = (0, _webrtcHelpers.getMediaDirectionFromTracks)(track.kind, _this.pc).includes('recv');
      });
      _this.remoteMediaStream = stream;
      _this.trigger('internalTrackUpdate');
    };
  }

  /* eslint-disable complexity */
  /**
   * Determines if ice gathering is necessary and sends it up when appropriate
   * @private
   * @returns {Promise|undefined}
   */


  (0, _createClass3.default)(WebRTCMediaEngine, [{
    key: '_prepareIceGatherer',
    value: function _prepareIceGatherer() {
      var _this2 = this;

      var needsIce = false;
      if (this.pc.iceGatheringState === 'new') {
        this.logger.info('ice gathering is in state "new", definitely need to block for ice gathering');
        needsIce = true;
      } else {
        var sdp = (0, _sdpTransform.parse)(this.pc.localDescription.sdp);
        ['audio', 'video', 'screen'].forEach(function (kind) {
          var directionKey = kind + 'Direction';
          if (_this2[directionKey] !== 'inactive' || getTargetMediaDirection(_this2, kind) !== _this2[directionKey] && getTargetMediaDirection(_this2, kind) !== 'inactive') {
            var media = sdp.media.find(function (m) {
              return m.type === kind;
            });
            if (media) {
              _this2.logger.info(kind + ' candidates already gathered');
            } else {
              _this2.logger.info('transitioning ' + kind + ' from inactive, ice needed');
              needsIce = true;
            }
          }
        });
      }

      var icePromise = void 0;
      if (needsIce) {
        icePromise = new _promise2.default(function (resolve) {
          _this2.logger.info('configuring ice gathering');
          _this2.pc.onicecandidate = function (event) {
            if (!event.candidate) {
              _this2.logger.info('ice gathering complete');
              _this2.pc.onicecandidate = undefined;
              resolve();
              return;
            }

            _this2.logger.info('got ice candidate');
          };
        });
      }

      return icePromise;
    }

    /* eslint-enable complexity */

    /**
     * Creates an offer SDP
     * @returns {Promise<string>}
     */

  }, {
    key: 'createOffer',
    value: function createOffer() {
      var _this3 = this;

      this.logger.info('beginning negotiation');

      var td = getTargetMediaDirection(this, 'video');
      var wantsVideo = td.includes('send') || td.includes('recv');

      var icePromise = this._prepareIceGatherer();

      return new _promise2.default(function (resolve) {
        if (_this3.gumming) {
          _this3.logger.info('gum in flight, waiting until it completes');
          // Since gum is protected by @oneflight, returning it here will block
          // until it completes but, more importantly, propagate a thrown
          // exception up the stack
          resolve(_this3._getUserMedia().then((0, _common.tap)(function () {
            return _this3.logger.info('gum completed');
          })));
          return;
        }

        resolve();
      }).then((0, _common.tap)(function () {
        return _this3.logger.info('creating offer', _this3.offerOptions);
      })).then(function () {
        // This is a (hopefully temporary) hack to deal with the fact that one
        // out of two browsers removes the remote stream when offerToReceive* is
        // false. We've already made the choice to disable the stream, but we
        // want to make sure we're still willing to receive an answer for it.
        _this3.offerOptions.offerToReceiveAudio = _this3.offerOptions.offerToReceiveAudio || !!_this3.pc.getReceivers().find(function (r) {
          return r.track.kind === 'audio';
        });
        _this3.offerOptions.offerToReceiveVideo = _this3.offerOptions.offerToReceiveVideo || !!_this3.pc.getReceivers().find(function (r) {
          return r.track.kind === 'video';
        });
        return _this3.pc.createOffer(_this3.offerOptions);
      }).then((0, _common.tap)(function (offer) {
        offer.sdp = (0, _webrtcHelpers.limitBandwith)(_this3.bandwidthLimit, offer.sdp);
      })).then((0, _common.tap)(function () {
        return _this3.logger.info('setting local description');
      })).then(function (offer) {
        return _this3.pc.setLocalDescription(offer);
      }).then((0, _common.tap)(function () {
        return icePromise && _this3.logger.info('blocking for ice gathering');
      })).then(function () {
        return icePromise;
      }).then((0, _common.tap)(function () {
        return _this3.logger.info('limiting bandwith');
      })).then(function () {
        return (0, _webrtcHelpers.limitBandwith)(_this3.bandwidthLimit, _this3.pc.localDescription.sdp);
      }).then((0, _common.tap)(function () {
        return wantsVideo && _this3.logger.info('confirm h264 in offer');
      })).then((0, _webrtcHelpers.ensureH264)(wantsVideo)).then(function (sdp) {
        if (_this3.localScreenShare) {
          var streamId = _this3.localScreenShare.id;
          var track = _this3.localScreenShare.getVideoTracks()[0];
          if (track) {
            var trackId = track.id;
            var msid = streamId + ' ' + trackId;
            var sections = sdp.split(msid);
            if (sections[1]) {
              sections[1] = '\r\na=content:slides' + sections[1];
              sdp = sections.join(msid);
              return sdp;
            }
          }

          sdp += 'a=content:slides\r\n';
        }
        return sdp;
      }).then((0, _common.tap)(function (sdp) {
        _this3.offerSdp = sdp;
      }));
    }

    /**
     * Receives an answer SDP
     * @param {string} sdp
     * @returns {Promise}
     */

  }, {
    key: 'acceptAnswer',
    value: function acceptAnswer(sdp) {
      var _this4 = this;

      this.logger.info('accepting answer');

      // Allow larger frames (this makes screenshare look *way* better, but no
      // idea what impact it's having on the camera stream - we may want to limit
      // it to just screen share at some future point)
      var defaultCodecParams = /max-mbps=27600;max-fs=920/g;
      var newCodecParams = 'max-mbps=27600;max-fs=8160';
      sdp = sdp.replace(defaultCodecParams, newCodecParams);

      // If the screenshare goes inactive, make sure the sdp includes a direction
      // config
      sdp = sdp.replace(/m=video 0(.*?\r\n)/, 'm=video 0$1a=inactive\r\n');
      return this.pc.setRemoteDescription(new RTCSessionDescription({
        sdp: sdp,
        type: 'answer'
      })).then(function () {
        _this4.logger.info('answer accepted');
        _this4.answerSdp = sdp;
        _this4.sendingAudio = (0, _webrtcHelpers.getMediaDirectionFromTracks)('audio', _this4.pc).includes('send');
        _this4.sendingVideo = (0, _webrtcHelpers.getMediaDirectionFromTracks)('video', _this4.pc).includes('send');
        _this4.trigger('answeraccepted');
        _this4.negotiationNeeded = false;
      });
    }
    /**
     * {@link MediaStreamConstraints} that'll be used for the next call to
     * {@link WebRTCMediaEngine.getUserMedia()}
     * @private
     * @type {MediaStreamConstraints}
     */

    /**
     * {@link RTCOfferOptions} that'll be used for the next call to
     * {@link RTCPeerConnection.createOffer}
     * @private
     * @type {RTCOfferOptions}
     */

    /**
     * Indicates whether or not a call to {@link MediaDevices#getUserMedia()} is
     * in flight
     * @private
     * @type {boolean}
     */

  }, {
    key: '_setNewMediaDirection',


    /**
     * Change media direction without consumer provided tracks or complex
     * constraints
     * @param {string} kind
     * @param {string} direction
     * @private
     * @returns {undefined}
     */
    value: function _setNewMediaDirection(kind, direction) {
      var _this5 = this;

      this.logger.info('setting ' + kind + ' direction to ' + direction);
      var constraint = direction.includes('send');
      this.constraints[kind] = constraint;

      if (constraint) {
        if (!this[kind + 'Direction'].includes('send')) {
          this._setNewMediaConstraint(kind, constraint);
        }
      } else {
        this.logger.info('removing any no-longer-needed ' + kind + ' tracks');
        if (!this.localMediaStream) {
          return;
        }
        this.localMediaStream.getTracks().filter(function (t) {
          return t.kind === kind;
        }).forEach(function (t) {
          _this5.logger.info('removing ' + kind + ' track ' + t.id + ' from localMediaStream');
          _this5.localMediaStream.removeTrack(t);
          _this5.logger.info('removing ' + kind + ' track ' + t.id + ' from peer connection');
          // Note: Doesn't like removing senders whose tracks are not live, so
          // t.stop() has to come after removeTrack()
          try {
            _this5.pc.removeTrack(_this5.pc.getSenders().find(function (s) {
              return s.track === t;
            }));
          } catch (err) {
            if (t.readyState === 'ended') {
              _this5.logger.warn('Suppressing error caused by trying to remove an ended track from a peer connection');
            } else {
              _this5.logger.warn('suppressing removeTrack error. We don\'t know why firefox does this, but we\'re still going to make sure the track is stopped');
            }
            _this5.logger.warn(err);
          }
          _this5.logger.info('setting receiving' + capitalize[kind] + ' to false');
          _this5['sending' + capitalize[kind]] = false;
          _this5.logger.info('stopping ' + kind + ' track ' + t.id);
          t.stop();
        });
      }
    }

    /**
     * Sets or replaces current track for $kind
     * @param {string} kind
     * @param {MediaStreamTrack} track
     * @returns {undefined}
     */

  }, {
    key: '_setNewMediaTrack',
    value: function _setNewMediaTrack(kind, track) {
      this.logger.info('setting new ' + kind + ' track');
      this.constraints[kind] = false;
      this.addOrReplaceTrack(track);
    }

    /**
     * Causes track for ${kind} to be set or replaced according to $constraint
     * @param {string} kind
     * @param {Object|boolean} constraint
     * @returns {undefined}
     */

  }, {
    key: '_setNewMediaConstraint',
    value: function _setNewMediaConstraint(kind, constraint) {
      this.logger.info('setting ' + kind + ' with new constraint');
      this.constraints[kind] = constraint;
      this._getUserMedia();
    }

    /**
     * Starts or stops an outbound screenshare
     *
     * @param {string} direction currently only inactive or sendonly
     * @param {Object|MediaStreamTrack} trackOrConstraint
     * @returns {Promise}
     */

  }, {
    key: '_setScreenShare',
    value: function _setScreenShare(direction, trackOrConstraint) {
      var _this6 = this;

      this.logger.info('calling _setScreenShare');
      targetMediaDirection.set(this, 'screen', direction);
      if (direction.includes('send')) {
        var constraint = (0, _defaults3.default)({}, trackOrConstraint, {
          mediaSource: 'application',
          width: {
            min: '160',
            max: '1920'
          },
          height: {
            min: '90',
            max: '1080'
          },
          frameRate: {
            min: '1',
            max: '30'
          }
        });

        this._setNewMediaConstraint('screen', constraint);
        return;
      }

      this.logger.info('removing existing screenshare tracks from peer connection and localScreenShare stream');
      this.pc.getSenders().filter(function (s) {
        return _this6.localScreenShare.getTracks().includes(s.track);
      }).forEach(function (s) {
        _this6.logger.info('removing screenshare track ' + s.track.id + ' from peer connection and localScreenShare stream');

        _this6.pc.removeTrack(s);
        _this6.localScreenShare.removeTrack(s.track);
        s.track.stop();

        _this6.logger.info('removed screenshare track ' + s.track.id + ' from peer connection and localScreenShare stream');
      });
    }

    // I don't see any further ways to reduce complexity without hurting
    // readability
    /* eslint-disable complexity */
    /**
     * Sets a media direction for a given media type. Almost certainly triggers
     * renegotiation. This is the method to use if you want to replace a track.
     * @param {string} kind audio|video
     * @param {string} direction sendonly|recvonly|sendrecv|inactive
     * @param {MediaStreamTrack|Object} trackOrConstraint
     * @returns {Promise}
     */

  }, {
    key: 'setMedia',
    value: function setMedia(kind, direction, trackOrConstraint) {
      this.logger.info('setMedia');
      if (kind === 'screen') {
        this.logger.info('setMedia: setting new screen direction');
        this._setScreenShare(direction, trackOrConstraint);
        return;
      }
      if (trackOrConstraint) {
        if (!direction.includes('send')) {
          throw new Error('Cannot set new ' + kind + ' track or constraint if direction does not include send');
        }

        if (trackOrConstraint instanceof MediaStreamTrack) {
          if (trackOrConstraint.kind !== kind) {
            throw new Error('track is not a valid ' + kind + ' media stream track');
          }

          this._setNewMediaTrack(kind, trackOrConstraint);
        } else {
          this._setNewMediaConstraint(kind, trackOrConstraint);
        }
      } else {
        if (direction === getTargetMediaDirection(this, kind)) {
          this.logger.info(kind + ' already transitioning to ' + direction + ', not making changes');
          return;
        }

        if (direction === this[kind + 'Direction']) {
          this.logger.info(kind + ' already set to ' + direction + ', not making changes');
          return;
        }
        this._setNewMediaDirection(kind, direction);
      }

      var shouldRecv = direction.includes('recv');

      targetMediaDirection.set(this, kind, direction);

      this.offerOptions['offerToReceive' + (0, _webrtcHelpers.kindToPropertyFragment)(kind)] = shouldRecv;

      if (shouldRecv) {
        if (this.remoteMediaStream && this.remoteMediaStream.getTracks().find(function (t) {
          return t.kind === kind;
        })) {
          this.unpauseReceivingMedia(kind);
        } else if (this.answerSdp) {
          this.triggerNegotiationNeeded();
        }
      } else if (this.remoteMediaStream && this.remoteMediaStream.getTracks().find(function (t) {
        return t.kind === kind;
      })) {
        this.pauseReceivingMedia(kind);
      }
    }

    /* eslint-enable complexity */

  }, {
    key: '_getUserMedia',

    /**
     * Wrapper around {@link MediaDevices#getUserMedia()} that delays the call one
     * tick to reduce the number of permissions dialogs presented to the user.
     * @name _getUserMedia
     * @returns {Promise<MediaStream>}
     */
    // It's not missing, but the decorator is throwing off eslint
    // eslint-disable-next-line require-jsdoc
    value: function _getUserMedia() {
      var _this7 = this;

      this.logger.info('enqueing request to get user media');
      return new _promise2.default(function (resolve) {
        return process.nextTick(resolve);
      }).then(function () {
        if (_this7.constraints.audio === true && _this7.pc.getSenders().find(function (s) {
          return s.track.kind === 'audio';
        })) {
          _this7.logger.info('already have a local audio track, removing constraint for a second one');
          (0, _deleteProperty2.default)(_this7.constraints, 'audio');
        }

        if (_this7.constraints.video === true && _this7.pc.getSenders().find(function (s) {
          return s.track.kind === 'video';
        })) {
          _this7.logger.info('already have a local video track, removing constraint for a second one');
          (0, _deleteProperty2.default)(_this7.constraints, 'video');
        }

        var _constraints = _this7.constraints,
            audio = _constraints.audio,
            video = _constraints.video,
            screen = _constraints.screen;


        return _promise2.default.all([(audio || video) && WebRTCMediaEngine.getUserMedia({ audio: audio, video: video }), screen && WebRTCMediaEngine.getUserMedia({ video: screen })]);
      }).then(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            userStream = _ref2[0],
            screenStream = _ref2[1];

        if (userStream) {
          _this7.logger.info('got local media stream with ' + userStream.getAudioTracks().length + ' audio tracks and ' + userStream.getVideoTracks().length + ' video tracks');
          userStream.getTracks().forEach(function (t) {
            return _this7.addOrReplaceTrack(t);
          });
        }

        if (screenStream) {
          if (_this7.localScreenShare) {
            _this7.logger.info('removing existing screenshare tracks from peer connection and localScreenShare stream');
            _this7.pc.getSenders().filter(function (s) {
              return _this7.localScreenShare.getTracks().includes(s.track);
            }).forEach(function (s) {
              _this7.pc.removeTrack(s);
              _this7.localScreenShare.removeTrack(s.track);
            });

            _this7.logger.info('adding new screen track to localScreenShare stream');
            screenStream.getTracks().forEach(function (t) {
              _this7.localScreenShare.addTrack(t);
              _this7.pc.addTrack(t, _this7.localScreenShare);
            });
          } else {
            _this7.logger.info('adding localScreenShare for the first time');
            _this7.localScreenShare = screenStream;

            _this7.logger.info('adding new screenshare track to peer connection');
            screenStream.getVideoTracks().forEach(function (t) {
              return _this7.pc.addTrack(t, screenStream);
            });
          }
        }

        _this7.constraints = {};
      }).catch(function (err) {
        _this7.trigger('error', err);
        return _promise2.default.reject(err);
      });
    }

    /**
     * adds or replaces a local @{link MediaStreamTrack}
     * @private
     * @param {MediaStreamTrack} track
     * @returns {undefined}
     */

  }, {
    key: 'addOrReplaceTrack',
    value: function addOrReplaceTrack(track) {
      if (!this.localMediaStream) {
        this.localMediaStream = new MediaStream();
      }
      this.logger.info('preparing to add ' + track.kind + ' to local media stream');
      var existing = this.pc.getSenders().find(function (s) {
        return s.track.kind === track.kind && s.track !== track;
      });
      if (existing) {
        this.logger.info('removing previous ' + track.kind + ' from local media stream');
        this.pc.removeTrack(existing);
        this.localMediaStream.removeTrack(existing.track);
        // it may not be appropriate to stop the track if it was supplied by the
        // engine consumer, but I'm inclined not to deal with that unless it
        // becomes a real issue.
        track.stop();
      }

      this.logger.info('adding ' + track.kind + ' to local media stream');
      this.localMediaStream.addTrack(track);
      this.logger.info('adding ' + track.kind + ' to peer connection');
      this.pc.addTrack(track, this.localMediaStream);

      this.logger.info('setting sending' + capitalize[track.kind] + ' to true');
      this['sending' + capitalize[track.kind]] = true;
    }

    /**
     * Stops sending useful bits on the identified track, but does not end it (the
     * camera/mic will stay on but the remote party(s) will not see/hear anything).
     * Avoids renegotiation. Throws if `kind` does not identify a track.
     * @param {string} kind
     * @returns {Promise}
     */

  }, {
    key: 'pauseSendingMedia',
    value: function pauseSendingMedia(kind) {
      var _this8 = this;

      if (!kind) {
        throw new Error('kind is required');
      }
      var senders = this.pc.getSenders().filter(function (s) {
        return s.track.kind === kind;
      });

      if (senders.length === 0) {
        throw new Error('No ' + kind + ' media senders to pause');
      }

      senders.forEach(function (s) {
        _this8.logger.info('pausing ' + kind + ' sender');
        s.track.enabled = false;
      });

      this.logger.info('setting sending' + capitalize[kind] + ' to false');
      this['sending' + capitalize[kind]] = false;
    }

    /**
     * Resumes sending bits on the identified track. Throws if `kind` does not
     * identify a track.
     * @param {string} kind
     * @returns {Promise}
     */

  }, {
    key: 'unpauseSendingMedia',
    value: function unpauseSendingMedia(kind) {
      var _this9 = this;

      if (!kind) {
        throw new Error('kind is required');
      }
      var senders = this.pc.getSenders().filter(function (s) {
        return s.track.kind === kind;
      });

      if (senders.length === 0) {
        throw new Error('No ' + kind + ' media senders to unpause');
      }

      senders.forEach(function (s) {
        _this9.logger.info('unpausing ' + kind + ' sender');
        s.track.enabled = true;
      });

      this.logger.info('setting sending' + capitalize[kind] + ' to true');
      this['sending' + capitalize[kind]] = true;
    }

    /**
     * Convenience function. Sets a remote track.enabled=false. Does not
     * renegotiate.Throws if `kind` does not identify a track.
     * @param {string} kind
     * @returns {Promise}
     */

  }, {
    key: 'pauseReceivingMedia',
    value: function pauseReceivingMedia(kind) {
      var _this10 = this;

      if (!kind) {
        throw new Error('kind is required');
      }
      if (!this.remoteMediaStream) {
        throw new Error('No remote media stream available');
      }
      var tracks = this.remoteMediaStream.getTracks().filter(function (t) {
        return t.kind === kind;
      });

      if (tracks.length === 0) {
        throw new Error('No remote ' + kind + ' media tracks to pause');
      }

      tracks.forEach(function (t) {
        _this10.logger.info('pausing remote ' + kind + ' track');
        t.enabled = false;
      });

      this.logger.info('setting receiving' + capitalize[kind] + ' to false');
      this['receiving' + capitalize[kind]] = false;
    }

    /**
     * Convenience function. Sets a remote track.enabled=true. Does not
     * renegotiate.Throws if `kind` does not identify a track.
     * @param {string} kind
     * @returns {Promise}
     */

  }, {
    key: 'unpauseReceivingMedia',
    value: function unpauseReceivingMedia(kind) {
      var _this11 = this;

      if (!kind) {
        throw new Error('kind is required');
      }
      if (!this.remoteMediaStream) {
        throw new Error('No remote media stream available');
      }
      var tracks = this.remoteMediaStream.getTracks().filter(function (t) {
        return t.kind === kind;
      });

      if (tracks.length === 0) {
        throw new Error('No remote ' + kind + ' media tracks to pause');
      }

      tracks.forEach(function (t) {
        _this11.logger.info('unpausing remote ' + kind + ' track');
        t.enabled = true;
      });

      this.logger.info('setting receiving' + capitalize[kind] + ' to true from ' + this['receiving' + capitalize[kind]]);
      this['receiving' + capitalize[kind]] = true;
    }

    /**
     * Stops all tracks and streams, closes the peer connection, and removes all
     * listeners
     * @returns {undefined}
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this.pc.signalingState !== 'closed') {
        this.pc.getSenders().forEach(function (s) {
          return s.track.stop();
        });
        this.pc.close();
      }

      this.pc.onnegotiationneeded = undefined;
      this.pc.ontrack = undefined;
      this.pc.onicecandidate = undefined;
      this.ended = true;
      this.off();
    }
  }, {
    key: 'triggerNegotiationNeeded',

    /**
     * Debounced helper for triggering `negotiationneeded`.
     * @private
     * @returns {undefined}
     */
    // It's not missing, but the decorator is throwing off eslint
    // eslint-disable-next-line require-jsdoc
    value: function triggerNegotiationNeeded() {
      this.trigger('negotiationneeded');
    }

    /**
     * Returns a string when attempting to serialize object
     * @returns {string}
     */

  }, {
    key: 'serialize',
    value: function serialize() {
      return 'WebRTCMediaEngine';
    }
  }]);
  return WebRTCMediaEngine;
}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'localMediaStream', [_commonEvented2.default], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'remoteMediaStream', [_commonEvented2.default], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'localScreenShare', [_commonEvented2.default], {
  enumerable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'offerSdp', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return '';
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'answerSdp', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return '';
  }
}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, 'sendingAudio', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, 'sendingVideo', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, 'receivingAudio', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, 'receivingVideo', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, 'ended', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, 'constraints', [_coreDecorators.nonenumerable], {
  enumerable: true,
  initializer: function initializer() {
    return {};
  }
}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, 'offerOptions', [_coreDecorators.nonenumerable], {
  enumerable: true,
  initializer: function initializer() {
    return {};
  }
}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, 'gumming', [_coreDecorators.nonenumerable, _commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _applyDecoratedDescriptor(_class.prototype, '_getUserMedia', [_dec, _common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_getUserMedia'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'triggerNegotiationNeeded', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'triggerNegotiationNeeded'), _class.prototype)), _class));
exports.default = WebRTCMediaEngine;


(0, _assign2.default)(WebRTCMediaEngine.prototype, _ampersandEvents2.default);
//# sourceMappingURL=engine.js.map
