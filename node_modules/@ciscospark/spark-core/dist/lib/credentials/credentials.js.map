{"version":3,"sources":["credentials.js"],"names":["Credentials","extend","keyFactory","scope","collections","userTokens","dataTypes","token","dataType","derived","canAuthorize","deps","fn","Boolean","supertoken","canRefresh","config","jwtRefreshCallback","props","prop","namespace","session","isRefreshing","default","type","ready","refreshTimer","undefined","buildLoginUrl","options","clientType","state","Error","client_id","redirect_uri","response_type","toBase64Url","authorizeUrl","stringify","buildLogoutUrl","logoutUrl","cisService","service","goto","calcRefreshTimeout","expiration","Math","floor","random","constructor","_dataTypes","forEach","key","set","bind","args","downscope","catch","reason","logger","error","resolve","serialize","parent","getClientToken","info","spark","request","method","uri","tokenUrl","form","grant_type","self_contained_token","auth","user","pass","client_secret","sendImmediately","shouldRefreshAccessToken","then","res","body","statusCode","reject","ErrorConstructor","select","_res","getUserToken","once","get","access_token","t","add","initialize","attrs","authorization","expires","scheduleRefresh","prototype","listenToOnce","authorizationString","parsed","parse","query","href","substr","indexOf","invalidate","clearTimeout","unset","err","warn","models","length","remove","refresh","tokens","jwt","requestAccessTokenFromJwt","st","all","map","revoke","expiresIn","Date","now","timeoutLength"],"mappings":"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","file":"credentials.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport querystring from 'querystring';\nimport url from 'url';\n\nimport {\n  base64,\n  makeStateDataType,\n  oneFlight,\n  tap,\n  whileInFlight\n} from '@ciscospark/common';\nimport {safeSetTimeout} from '@ciscospark/common-timers';\nimport {clone, cloneDeep, isObject} from 'lodash';\n\nimport SparkPlugin from '../spark-plugin';\nimport {persist, waitForValue} from '../storage/decorators';\n\nimport grantErrors from './grant-errors';\nimport {filterScope, sortScope} from './scope';\nimport Token from './token';\nimport TokenCollection from './token-collection';\n\n/**\n * @class\n */\nconst Credentials = SparkPlugin.extend({\n  collections: {\n    userTokens: TokenCollection\n  },\n\n  dataTypes: {\n    token: makeStateDataType(Token, 'token').dataType\n  },\n\n  derived: {\n    canAuthorize: {\n      deps: [\n        'supertoken',\n        'supertoken.canAuthorize',\n        'canRefresh'\n      ],\n      fn() {\n        return Boolean(this.supertoken && this.supertoken.canAuthorize || this.canRefresh);\n      }\n    },\n    canRefresh: {\n      deps: [\n        'supertoken',\n        'supertoken.canRefresh'\n      ],\n      fn() {\n        // If we're operating in JWT mode, we have to delegate to the consumer\n        if (this.config.jwtRefreshCallback) {\n          return true;\n        }\n\n        return Boolean(this.supertoken && this.supertoken.canRefresh);\n      }\n    }\n  },\n\n  props: {\n    supertoken: makeStateDataType(Token, 'token').prop\n  },\n\n  namespace: 'Credentials',\n\n  session: {\n    isRefreshing: {\n      default: false,\n      type: 'boolean'\n    },\n    /**\n     * Becomes `true` once the {@link loaded} event fires.\n     * @see {@link SparkPlugin#ready}\n     * @instance\n     * @memberof Credentials\n     * @type {boolean}\n     */\n    ready: {\n      default: false,\n      type: 'boolean'\n    },\n    refreshTimer: {\n      default: undefined,\n      type: 'any'\n    }\n  },\n\n  /**\n   * Generates an OAuth Login URL. Prefers the api.ciscospark.com proxy if the\n   * instance is initialize with an authorizatUrl, but fallsback to idbroker\n   * as the base otherwise.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {string}\n   */\n  buildLoginUrl(options = {clientType: 'public'}) {\n    /* eslint-disable camelcase */\n    if (options.state && !isObject(options.state)) {\n      throw new Error('if specified, `options.state` must be an object');\n    }\n\n    options.client_id = this.config.client_id;\n    options.redirect_uri = this.config.redirect_uri;\n    options.scope = this.config.scope;\n\n    options = cloneDeep(options);\n\n    if (!options.response_type) {\n      options.response_type = options.clientType === 'public' ? 'token' : 'code';\n    }\n    Reflect.deleteProperty(options, 'clientType');\n\n    if (options.state) {\n      options.state = base64.toBase64Url(JSON.stringify(options.state));\n    }\n    return `${this.config.authorizeUrl}?${querystring.stringify(options)}`;\n    /* eslint-enable camelcase */\n  },\n\n  /**\n   * Generates a Logout URL\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {[type]}\n   */\n  buildLogoutUrl(options = {}) {\n    return `${this.config.logoutUrl}?${querystring.stringify(Object.assign({\n      cisService: this.config.service,\n      goto: this.config.redirect_uri\n    }, options))}`;\n  },\n\n  /**\n   * Generates a number between 60% - 90% of expired value\n   * @instance\n   * @memberof Credentials\n   * @param {number} expiration\n   * @private\n   * @returns {number}\n   */\n  calcRefreshTimeout(expiration) {\n    return Math.floor((Math.floor(Math.random() * 4) + 6) / 10 * expiration);\n  },\n\n  constructor(...args) {\n    // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n    // function.\n    this._dataTypes = cloneDeep(this._dataTypes);\n    Object.keys(this._dataTypes).forEach((key) => {\n      if (this._dataTypes[key].set) {\n        this._dataTypes[key].set = this._dataTypes[key].set.bind(this);\n      }\n    });\n    // END HACK\n    Reflect.apply(SparkPlugin, this, args);\n  },\n\n  /**\n   * Downscopes a token\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @private\n   * @returns {Promise<Token>}\n   */\n  downscope(scope) {\n    return this.supertoken.downscope(scope)\n      .catch((reason) => {\n        this.logger.error(`credentials: failed to downscope supertoken to ${scope}`, reason);\n        this.logger.error(`credentials: falling back to supertoken for ${scope}`);\n        return Promise.resolve(new Token(Object.assign({scope}, this.supertoken.serialize())), {parent: this});\n      });\n  },\n\n  /**\n   * Requests a client credentials grant and returns the token. Given the\n   * limited use for such tokens as this time, this method does not cache its\n   * token.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} options\n   * @returns {Promise<Token>}\n   */\n  getClientToken(options = {}) {\n    this.logger.info('credentials: requesting client credentials grant');\n\n    options = options || {};\n    options.scope = options.scope || 'webexsquare:admin';\n\n    return this.spark.request({\n      /* eslint-disable camelcase */\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'client_credentials',\n        scope: options.scope,\n        self_contained_token: true\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n      /* eslint-enable camelcase */\n    })\n      .then((res) => new Token(res.body, {parent: this}))\n      .catch((res) => {\n        if (res.statusCode !== 400) {\n          return Promise.reject(res);\n        }\n\n        const ErrorConstructor = grantErrors.select(res.body.error);\n        return Promise.reject(new ErrorConstructor(res._res || res));\n      });\n  },\n\n  @oneFlight({keyFactory: (scope) => scope})\n  @waitForValue('@')\n  /**\n   * Resolves with a token with the specified scopes. If no scope is specified,\n   * defaults to omit(spark.credentials.scope, 'spark:kms'). If no such token is\n   * available, downscopes the supertoken to that scope.\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  getUserToken(scope) {\n    return Promise.resolve(!this.isRefreshing || new Promise((resolve) => {\n      this.logger.info('credentials: token refresh inflight; delaying getUserToken until refresh completes');\n      this.once('change:isRefreshing', () => {\n        this.logger.info('credentials: token refresh complete; reinvoking getUserToken');\n        resolve();\n      });\n    }))\n      .then(() => {\n        if (!this.canAuthorize) {\n          this.logger.info('credentials: cannot produce an access token from current state');\n          return Promise.reject(new Error('Current state cannot produce an access token'));\n        }\n\n        if (!scope) {\n          scope = filterScope('spark:kms', this.config.scope);\n        }\n\n        scope = sortScope(scope);\n\n        if (scope === sortScope(this.config.scope)) {\n          return Promise.resolve(this.supertoken);\n        }\n\n        const token = this.userTokens.get(scope);\n\n        // we should also check for the token.access_token since token object does\n        // not get cleared on unsetting while logging out.\n        if (!token || !token.access_token) {\n          return this.downscope(scope)\n            .then(tap((t) => this.userTokens.add(t)));\n        }\n\n        return Promise.resolve(token);\n      });\n  },\n\n  @persist('@')\n  /**\n   * Initializer\n   * @instance\n   * @memberof Credentials\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {Credentials}\n   */\n  initialize(attrs, options) {\n    if (attrs) {\n      if (typeof attrs === 'string') {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.access_token) {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.authorization) {\n        if (attrs.authorization.supertoken) {\n          this.supertoken = attrs.authorization.supertoken;\n        }\n        else {\n          this.supertoken = attrs.authorization;\n        }\n      }\n\n      // schedule refresh\n      if (this.supertoken && this.supertoken.expires) {\n        this.scheduleRefresh(this.supertoken.expires);\n      }\n    }\n\n    Reflect.apply(SparkPlugin.prototype.initialize, this, [attrs, options]);\n\n    this.listenToOnce(this.parent, 'change:config', () => {\n      if (this.config.authorizationString) {\n        const parsed = url.parse(this.config.authorizationString, true);\n        /* eslint-disable camelcase */\n        this.config.client_id = parsed.query.client_id;\n        this.config.redirect_uri = parsed.query.redirect_uri;\n        this.config.scope = parsed.query.scope;\n        this.config.authorizeUrl = parsed.href.substr(0, parsed.href.indexOf('?'));\n        /* eslint-enable camelcase */\n      }\n    });\n\n    this.spark.once('loaded', () => {\n      this.ready = true;\n    });\n  },\n\n  @oneFlight\n  @waitForValue('@')\n  /**\n   * Clears all tokens from store them from the stores.\n   *\n   * This is no longer quite the right name for this method, but all of the\n   * alternatives I'm coming up with are already taken.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  invalidate() {\n    this.logger.info('credentials: invalidating tokens');\n\n    // clear refresh timer\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.unset('refreshTimer');\n    }\n\n    try {\n      this.unset('supertoken');\n    }\n    catch (err) {\n      this.logger.warn('credentials: failed to clear supertoken', err);\n    }\n\n    while (this.userTokens.models.length) {\n      try {\n        this.userTokens.remove(this.userTokens.models[0]);\n      }\n      catch (err) {\n        this.logger.warn('credentials: failed to remove user token', err);\n      }\n    }\n\n    this.logger.info('credentials: finished removing tokens');\n\n    // Return a promise to give the storage layer a tick or two to clear\n    // localStorage\n    return Promise.resolve();\n  },\n\n  @oneFlight\n  @whileInFlight('isRefreshing')\n  @waitForValue('@')\n  /**\n   * Removes the supertoken and child tokens, then refreshes the supertoken;\n   * subsequent calls to {@link Credentials#getUserToken()} will re-downscope\n   * child tokens. Enqueus revocation of previous previousTokens. Yes, that's\n   * the correct number of \"previous\"es.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  refresh() {\n    this.logger.info('credentials: refresh requested');\n\n    const supertoken = this.supertoken;\n    const tokens = clone(this.userTokens.models);\n\n    // This is kind of a leaky abstraction, since it relies on the authorization\n    // plugin, but the only alternatives I see are\n    // 1. put all JWT support in core\n    // 2. have separate jwt and non-jwt auth plugins\n    // while I like #2 from a code simplicity standpoint, the third-party DX\n    // isn't great\n    if (this.config.jwtRefreshCallback) {\n      return this.config.jwtRefreshCallback(this.spark)\n        .then((jwt) => this.spark.authorization.requestAccessTokenFromJwt({jwt}));\n    }\n\n    return supertoken.refresh()\n      .then((st) => {\n        // clear refresh timer\n        if (this.refreshTimer) {\n          clearTimeout(this.refreshTimer);\n          this.unset('refreshTimer');\n        }\n        this.supertoken = st;\n        return Promise.all(tokens.map((token) => this.downscope(token.scope)\n          // eslint-disable-next-line max-nested-callbacks\n          .then((t) => {\n            this.logger.info(`credentials: revoking token for ${token.scope}`);\n            return token.revoke()\n              .catch((err) => {\n                this.logger.warn('credentials: failed to revoke user token', err);\n              })\n              .then(() => {\n                this.userTokens.remove(token.scope);\n                this.userTokens.add(t);\n              });\n          })));\n      })\n      .then(() => {\n        this.scheduleRefresh(this.supertoken.expires);\n      });\n  },\n\n  /**\n   * Schedules a token refresh or refreshes the token if token has expired\n   * @instance\n   * @memberof Credentials\n   * @param {number} expires\n   * @private\n   * @returns {undefined}\n   */\n  scheduleRefresh(expires) {\n    const expiresIn = expires - Date.now();\n    if (expiresIn > 0) {\n      const timeoutLength = this.calcRefreshTimeout(expiresIn);\n      this.refreshTimer = safeSetTimeout(() => this.refresh(), timeoutLength);\n    }\n    else {\n      this.refresh();\n    }\n  }\n\n});\n\nexport default Credentials;\n"]}